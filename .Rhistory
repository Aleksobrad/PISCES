reticulate::py_discover_config(required_module = "phate")
retculate::import("phate")
library(phateR)
reticulate::import("phate")
reticulate::py_discover_config(required_module = "phate")
version
if (!suppressWarnings(require(devtools))) install.packages("devtools")
reticulate::py_install("phate", pip=TRUE)
devtools::install_github("KrishnaswamyLab/phateR")
install.packages('Rtools')
devtools::install_github("KrishnaswamyLab/phateR")
devtools::install_github("KrishnaswamyLab/phateR")
#' Generates a gene expression signature (GES) using internal normalization.
#'
#' @param cpm.mat Matrix of CPM-normalized gene expression data (genes X samples).
#' @return GES matrix.
#' @export
GESTransform <- function(cpm.mat) {
ges.mat <- t(apply(cpm.mat, 1, function(x) {
(x - mean(x)) / sd(x)
}))
return(ges.mat)
}
ges.mat <- GESTransform(ges.mat)
ges.mat <- readRDS('C://Users/lvlah/linux/ac_lab/data/GTEx/subTissue_tpm/GTEx_artery-aorta_tpm.rds')
ges.mat <- GESTransform(ges.mat)
net.obj <- readRDS('C://Users/lvlah/linux/ac_lab/GTEx-Networks/pruned_networks/brain-anterior-cingulate-cortex-ba24_pruned.rds')
viper(ges.mat[,1:3], net.obj[1:3])
library(viper)
viper(ges.mat[,1:3], net.obj[1:3])
write.table(ges.mat, file = 'C://Users/lvlah/linux/ac_lab/data/pyther_data/gtex-aorta_ges.tsv',
sep = '\t', row.names = TRUE, col.names = TRUE, quote = FALSE)
dim(ges.mat)
### recreate VIPER, step by step
t2.obj <- rank(ges.mat[,1]) / length(ges.mat[,1] + 1)
### recreate VIPER, step by step
t2.obj <- rank(ges.mat[,1]) / length(ges.mat[,1] + 1)
pos <- match(rownames(t2.obj, names(net.obj$ENSG00000000003)))
t2.obj <- qnorm(t2.obj[pos])
pos <- match(rownames(t2.obj, names(net.obj$ENSG00000000003$tfmode)))
names(net.obj$ENSG00000000003$tfmode)
pos <- match(rownames(t2.obj), names(net.obj$ENSG00000000003$tfmode))
t2.obj <- qnorm(t2.obj[pos])
t2.obj
### recreate VIPER, step by step
t2.obj <- rank(ges.mat[,1]) / length(ges.mat[,1] + 1)
t2.obj
pos
pos <- match(names(t2.obj), names(net.obj$ENSG00000000003$tfmode))
pos
### recreate VIPER, step by step
t2.obj <- rank(ges.mat[,1]) / length(ges.mat[,1] + 1)
pos <- match(names(net.obj$ENSG00000000003$tfmode), names(t2.obj))
t2.obj <- qnorm(t2.obj[pos])
t2.obj
t2.obj <- qnorm(t2.obj)
head(t2.obj)
head(ges.mat[,1])
### recreate VIPER, step by step
t2.obj <- rank(ges.mat[,1]) / length(ges.mat[,1] + 1)
head(t2.obj)
### recreate VIPER, step by step
t2.obj <- rank(ges.mat[,1])
head(t2.obj)
### recreate VIPER, step by step
t2.obj <- rank(ges.mat[,1]) / (length(ges.mat[,1]) + 1)
head(t2.obj)
t2.obj <- qnorm(t2.obj)
head(t2.obj)
### recreate VIPER, step by step
t2.obj <- rank(ges.mat[,1]) / (length(ges.mat[,1]) + 1)
t2q.obj <- qnorm(t2.obj)
t1.obj <- abs(t2.obj - 0.5) * 2
t1.obj <- t1.obj + (1 - max(t1.obj)) / 2
t1q.obj <- qnorm(t1.obj)
head(t1q.obj)
### recreate VIPER, step by step
t2.obj <- rank(ges.mat[,1:2]) / (nrow(ges.mat) + 1)
t2q.obj <- qnorm(t2.obj)
t1.obj <- abs(t2.obj - 0.5) * 2
t1.obj <- t1.obj + (1 - max(t1.obj)) / 2
t1q.obj <- qnorm(t1.obj)
head(t1q.obj)
### recreate VIPER, step by step
t2.obj <- apply(rank, 2, ges.mat[,1:2]) / (nrow(ges.mat) + 1)
t2q.obj <- qnorm(t2.obj)
### recreate VIPER, step by step
t2.obj <- apply(ges.mat[,1:2], 2, rank) / (nrow(ges.mat) + 1)
t2q.obj <- qnorm(t2.obj)
head(t2.obj)
t2q.obj <- qnorm(t2.obj)
head(t2q.obj)
t1.obj <- abs(t2.obj - 0.5) * 2
t1.obj <- t1.obj + (1 - max(t1.obj)) / 2
t1q.obj <- qnorm(t1.obj)
head(t1q.obj)
viper(ges.mat[,1:3], net.obj[1:3])
ic.vec <- net.obj$ENSG00000000003$likelihood
ic.vec
ic.vec <- net.obj$ENSG00000000003$likelihood
ic.vec <- ic.vec / max(ic.vec)
ic.vec
ic.vec <- scale(ic.vec, center = FALSE, scale = sum(ic.vec))
ic.vec
?scale
ic.vec <- net.obj$ENSG00000000003$likelihood
ic.vec <- ic.vec / max(ic.vec)
ic.vec.scale <- scale(ic.vec, center = FALSE, scale = sum(ic.vec))
(ic.vec - mean(ic.vec)) / sum(ic.vec)
head(ic.vec.scale)
ic.vec / sum(ic.vec)
as.list(ic.vec.scale)
ic.vec.scale[[1]]
ic.vec.scale[1]
ic.vec.scale[1]
ic.vec.scale
ic.vec.scale[,1]
ic.vec / sum(ic.vec)
viper(ges.mat[,1:3], net.obj[1:3])
viper(ges.mat[,1:3], net.obj[1:2])
?viper
viper(ges.mat[,1:3], net.obj[1:2], eset.filter = FALSE)
viper(ges.mat[,1:3], net.obj[1:3], eset.filter = FALSE)
### MOR and weight matrices
targets <- unique(unlist(lapply(net.obj, function(x) names(x$tfmode)), use.names = FALSE))
targets
### MOR and weight matrices
targets <- unique(unlist(lapply(net.obj[1:3], function(x) names(x$tfmode)), use.names = FALSE))
targets
### MOR and weight matrices
targets <- unique(unlist(lapply(net.obj[1:3], function(x) names(x$tfmode)), use.names = FALSE))
# 1.2 Create the Mode of Regulation matrix from the regulon object.
mor <- sapply(net.obj[1:3], function(x, genes) {
return(x$tfmode[match(genes, names(x$tfmode))])
}, genes = targets)
mor
wts <- sapply(net.obj[1:3], function(x, genes) {
tmp <- x$likelihood[match(genes, names(x$tfmode))]
tmp[is.na(match(genes, names(x$tfmode)))] <- NA
return(tmp/max(tmp, na.rm = T))
}, genes = targets)
wts
head(wts)
head(scale(wts, center = FALSE, scale = colSums(wts)))
mor[is.na(mor)] <- 0
wts[is.na(wts)] <- 0
head(wts)
head(scale(wts, center = FALSE, scale = colSums(wts)))
head(wts / colSums(wts))
dim(mor)
net.obj$ENSG00000000003$tfmode
wt.vec <- net.obj$ENSG00000000003$tfmode
wt.vec <- wt.vec / max(wt.vec)
wt.vec <- wt.vec / sum(wt.vec)
wt.vec
'ENSG00000168813' %in% names(wt.vec)
'ENSG00000105854' %in% names(wt.vec)
wt.vec['ENSG00000105854']
wt.vec['ENSG00000136044']
head(net.obj$ENSG00000000003$tfmode)
head(net.obj$ENSG00000000003$likelihood)
wtss <- scale(wts, center = FALSE, scale = colSums(wts))
head(wtss)
wts.vec <- net.obj$ENSG00000000003$likelihood
wts.vec <- wts.vec / max(wts.vec)
wts.vec <- wts.vec / sum(wts.vec)
wts.vec['ENSG00000105854']
head(wts.vec)
match('ENSG00000105854', names(net.obj$ENSG00000000003$tfmode))
wts.vec[match('ENSG00000105854', names(net.obj$ENSG00000000003$tfmode))]
wts.vec[match('ENSG00000147475', names(net.obj$ENSG00000000003$tfmode))]
net.obj$ENSG00000000003$tfmode
net.obj$ENSG00000000003$tfmode['ENSG00000105854']
net.obj$ENSG00000000003$tfmode['ENSG00000164904']
net.obj$ENSG00000000003$tfmode['ENSG00000147475']
viper(ges.mat[,1:3], net.obj[1:3], eset.filter = FALSE)
### GES adjustment
t2.obj <- apply(ges.mat[,1:2], 2, rank) / (nrow(ges.mat) + 1)
t2q.obj <- qnorm(t2.obj)
t1.obj <- abs(t2.obj - 0.5) * 2
t1.obj <- t1.obj + (1 - max(t1.obj)) / 2
t1q.obj <- qnorm(t1.obj)
t(mor * wtss)
mor <- sapply(net.obj[1:3], function(x, genes) {
return(x$tfmode[match(genes, names(x$tfmode))])
}, genes = targets)
wts <- sapply(net.obj[1:3], function(x, genes) {
tmp <- x$likelihood[match(genes, names(x$tfmode))]
tmp[is.na(match(genes, names(x$tfmode)))] <- NA
return(tmp/max(tmp, na.rm = T))
}, genes = targets)
mor[is.na(mor)] <- 0
wts[is.na(wts)] <- 0
wtss <- scale(wts, center = FALSE, scale = colSums(wts))
t(mor*wtss)
dim(t(mor*wtss))
mor*wtss
### MOR and weight matrices
targets <- unique(unlist(lapply(net.obj[1:3], function(x) names(x$tfmode)), use.names = FALSE))
t(mor*wtss) %*% t2q[targets,]
t(mor*wtss) %*% t2q.obj[targets,]
## 1-tail
t1.es <- t((1 - abs(mor)) * wtss) %*% t1q.obj[targets,]
t1.es
## 2-tail
t2.es <- t(mor*wtss) %*% t2q.obj[targets,]
## 1-tail
t1.es <- t((1 - abs(mor)) * wtss) %*% t1q.obj[targets,]
ss <- sign(t2.es)
tot.es <- (abs(t2.es) + t1.es * (t1.es > 0)) * ss
tot.es
viper(ges.mat[,1:2], net.obj[1:3], eset.filter = FALSE)
## make NES
lwt <- sqrt(colsums(wts**2))
nes <- tot.es * lwt
## make NES
lwt <- sqrt(colSums(wts**2))
nes <- tot.es * lwt
nes
lwt
library(ggplot2)
setwd('C://Users/lvlah/linux/ac_lab/PISCES-dev/')
bootcamp.dir <- 'C://Users/lvlah/linux/ac_lab/sc-bootcamp_21/'
devtools::document(); devtools::load_all()
## load data
seur.obj <- readRDS(paste(bootcamp.dir, 'cbmc_gene_seurat.rds', sep = ''))
library(Seurat)
## load data
seur.obj <- readRDS(paste(bootcamp.dir, 'cbmc_gene_seurat.rds', sep = ''))
abt.mat <- seur.obj@assays$ADT
rna.mat <- as.matrix(seur.obj@assays$RNA@counts)
## create seurat object
seurat.obj <- CreateSeuratObject(counts = rna.mat[, 1:250], project = 'sc-bootcamp', min.cells = 3, min.features = 200)
## QC analysis
mt.features <- intersect(mt.genes$hum.symb, rownames(seurat.obj))
seurat.obj[["percent.mt"]] <- PercentageFeatureSet(object = seurat.obj, features = mt.features)
QCPlots(seurat.obj)
## filtration and SCT normalization
seurat.obj <- subset(seurat.obj, subset = nCount_RNA > 1000 & nFeature_RNA < 3000 & percent.mt < 10)
seurat.obj <- SCTransform(seurat.obj, vars.to.regress = 'percent.mt', verbose = FALSE)
## seurat gene expression clustering
seurat.obj <- RunPCA(seurat.obj, verbose = FALSE)
seurat.obj <- FindNeighbors(seurat.obj, dims = 1:30, verbose = FALSE)
seurat.obj <- FindClusters(seurat.obj, verbose = FALSE)
## create distance matrix
seurat.obj <- CorDist(seurat.obj)
## metacell generation
meta.mats <- MetaCells(as.matrix(seurat.obj@assays$RNA@counts), seurat.dist,
seurat.obj$seurat_clusters, min.samps = 500, num.neighbors = 10)
## metacell generation
meta.mats <- MetaCells(as.matrix(seurat.obj@assays$RNA@counts), seurat.obj@assays$SCT@misc$dist.mat,
seurat.obj$seurat_clusters, min.samps = 500, num.neighbors = 10)
## load networks and add to PISCES
net.files <- list.files('C://Users/lvlah/linux/ac_lab/sc-bootcamp_21/mcell-nets/', full.names = TRUE)
net.list <- list()
for (i in 1:length(net.files)) {
net.list[[i]] <- readRDS(net.files[i])
}
saveRDS(net.list, file = 'C://Users/lvlah/linux/ac_lab/sc-bootcamp_21/cbmc_nets.rds')
## run viper
vip.obj <- PISCESViper(seurat.obj, net.list)
## generate PISCES object; normalize, generate internal GES
seurat.obj <- AddPISCESAssay(seurat.obj)
seurat.obj <- CPMTransform(seurat.obj)
seurat.obj <- GESTransform(seurat.obj)
seurat.obj@assays$PISCES@data
seurat.obj@active.assay
## run viper
vip.obj <- PISCESViper(seurat.obj, net.list)
dim(vip.obj@assays$PISCES@scale.data)
intersect(rownames(vip.obj@assays$PISCES@scale.data), rownames(abt.mat))
# cluster
vip.obj <- CorDist(vip.obj, use.scaled = TRUE)
# cluster
vip.obj <- CorDist(vip.obj)
vip.obj <- LouvainResRange(vip.obj, rmin = 10, rmax = 25)
vip.obj@assays$PISCES@misc$pisces.cluster
vip.obj@assays$PISCES@misc$clustering.obj$sils
head(vip.obj@assays$PISCES@misc$pisces.cluster)
table(vip.obj@assays$PISCES@misc$pisces.cluster)
table(vip.obj@assays$PISCES@misc$clustering.obj$clusterings$res20)
devtools::document(); devtools::load_all()
vip.obj <- MWUMrs(vip.obj)
# generate umap and mrs
vip.obj <- MakeUMAP(vip.obj)
devtools::document(); devtools::load_all()
# generate umap and mrs
vip.obj <- MakeUMAP(vip.obj)
vip.obj <- MWUMrs(vip.obj)
# check for PISCES assay
# check for MRs
# fill in clustering if missing
}
MRHeatmap <- function(pisces.obj, num.mrs = 10, clust.vect, plot.title = '') {
# check for PISCES assay
if (!('PISCES' %in% Assays(data.object))) {
print("Error: No PISCES assay in supplied object...")
return(NULL)
}
# fetch objects
vip.mat <- pisces.obj@assays$PISCES@scale.data
vip.mrs <- pisces.obj@assays$PISCES@misc$mwuMRs
if (missing(clust.vect)) {
clust.vect <- pisces.obj@assays$PISCES@misc$pisces.cluster
}
# build mr set
mr.set <- unique(unlist(lapply(vip.mrs, function(x) {names(x$positive[1:num.mrs])} )))
# build plot matrix and color breaks
cell.order <- names(sort(clust.vect))
plot.mat <- vip.mat[mr.set, cell.order]
mat.breaks <- QuantileBreaks(plot.mat, 100)
# cluster annotation
annot.df <- data.frame('Cluster' = as.factor(clust.vect))
clust.colors <- ClusterColors(length(unique(clust.vect))); names(clust.colors) <- unique(clust.vect)
annot.color <- list('Cluster' = clust.colors)
# make plot
plot.obj <- pheatmap::pheatmap(plot.mat, main = plot.title,
annotation_col = annot.df, annotation_colors = annot.color,
cluster_cols = FALSE, show_colnames = FALSE,
cluster_rows = FALSE, show_rownames = TRUE,
breaks = mat.breaks, color = ColorLevels(length(mat.breaks) - 1, 'vip'))
}
MRHeatmap(vip.obj)
MRHeatmap <- function(pisces.obj, num.mrs = 10, clust.vect, plot.title = '') {
# check for PISCES assay
if (!('PISCES' %in% Assays(pisces.obj))) {
print("Error: No PISCES assay in supplied object...")
return(NULL)
}
# fetch objects
vip.mat <- pisces.obj@assays$PISCES@scale.data
vip.mrs <- pisces.obj@assays$PISCES@misc$mwuMRs
if (missing(clust.vect)) {
clust.vect <- pisces.obj@assays$PISCES@misc$pisces.cluster
}
# build mr set
mr.set <- unique(unlist(lapply(vip.mrs, function(x) {names(x$positive[1:num.mrs])} )))
# build plot matrix and color breaks
cell.order <- names(sort(clust.vect))
plot.mat <- vip.mat[mr.set, cell.order]
mat.breaks <- QuantileBreaks(plot.mat, 100)
# cluster annotation
annot.df <- data.frame('Cluster' = as.factor(clust.vect))
clust.colors <- ClusterColors(length(unique(clust.vect))); names(clust.colors) <- unique(clust.vect)
annot.color <- list('Cluster' = clust.colors)
# make plot
plot.obj <- pheatmap::pheatmap(plot.mat, main = plot.title,
annotation_col = annot.df, annotation_colors = annot.color,
cluster_cols = FALSE, show_colnames = FALSE,
cluster_rows = FALSE, show_rownames = TRUE,
breaks = mat.breaks, color = ColorLevels(length(mat.breaks) - 1, 'vip'))
}
MRHeatmap(vip.obj)
MRHeatmap <- function(pisces.obj, num.mrs = 10, clust.vect, plot.title = '') {
# check for PISCES assay
if (!('PISCES' %in% Assays(pisces.obj))) {
print("Error: No PISCES assay in supplied object...")
return(NULL)
}
# fetch objects
vip.mat <- pisces.obj@assays$PISCES@scale.data
vip.mrs <- pisces.obj@assays$PISCES@misc$mwuMRs
vip.mrs <- vip.mrs[order(names(vip.mrs))]
if (missing(clust.vect)) {
clust.vect <- pisces.obj@assays$PISCES@misc$pisces.cluster
}
# build mr set
mr.set <- unique(unlist(lapply(vip.mrs, function(x) {names(x$positive[1:num.mrs])} )))
# build plot matrix and color breaks
cell.order <- names(sort(clust.vect))
plot.mat <- vip.mat[mr.set, cell.order]
mat.breaks <- QuantileBreaks(plot.mat, 100)
# cluster annotation
annot.df <- data.frame('Cluster' = as.factor(clust.vect))
clust.colors <- ClusterColors(length(unique(clust.vect))); names(clust.colors) <- unique(clust.vect)
annot.color <- list('Cluster' = clust.colors)
# make plot
plot.obj <- pheatmap::pheatmap(plot.mat, main = plot.title,
annotation_col = annot.df, annotation_colors = annot.color,
cluster_cols = FALSE, show_colnames = FALSE,
cluster_rows = FALSE, show_rownames = TRUE,
breaks = mat.breaks, color = ColorLevels(length(mat.breaks) - 1, 'vip'))
}
MRHeatmap(vip.obj)
MRHeatmap <- function(pisces.obj, num.mrs = 10, clust.vect, plot.title = '') {
# check for PISCES assay
if (!('PISCES' %in% Assays(pisces.obj))) {
print("Error: No PISCES assay in supplied object...")
return(NULL)
}
# fetch objects
vip.mat <- pisces.obj@assays$PISCES@scale.data
vip.mrs <- pisces.obj@assays$PISCES@misc$mwuMRs
vip.mrs <- vip.mrs[order(names(vip.mrs))]
if (missing(clust.vect)) {
clust.vect <- pisces.obj@assays$PISCES@misc$pisces.cluster
}
# build mr set
mr.set <- unique(unlist(lapply(vip.mrs, function(x) {names(x$positive[1:num.mrs])} )))
# build plot matrix and color breaks
cell.order <- names(sort(clust.vect))
plot.mat <- vip.mat[mr.set, cell.order]
mat.breaks <- QuantileBreaks(plot.mat, 100)
# cluster annotation
annot.df <- data.frame('Cluster' = as.factor(clust.vect))
clust.colors <- ClusterColors(length(unique(clust.vect))); names(clust.colors) <- sort(unique(clust.vect))
annot.color <- list('Cluster' = clust.colors)
# make plot
plot.obj <- pheatmap::pheatmap(plot.mat, main = plot.title,
annotation_col = annot.df, annotation_colors = annot.color,
cluster_cols = FALSE, show_colnames = FALSE,
cluster_rows = FALSE, show_rownames = TRUE,
breaks = mat.breaks, color = ColorLevels(length(mat.breaks) - 1, 'vip'))
}
MRHeatmap(vip.obj)
devtools::document(); devtools::load_all()
